{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n} // Converting between Date and String types is handled via a \"schema\".\n// The schema is an array of strings, split into strings with identical\n// characters. So, 'mm/dd/yyyy' will be ['mm', '/', 'dd', '/', 'yyyyy'].\n\n\nexport var formatToSchema = function formatToSchema(format) {\n  if (!format) return undefined;\n  var result = [];\n  var i = 0;\n  var part;\n\n  while (i < format.length) {\n    if (!part || part[0] !== format[i]) {\n      if (part) result.push(part);\n      part = format[i];\n    } else {\n      part += format[i];\n    }\n\n    i += 1;\n  }\n\n  if (part) result.push(part);\n  return result;\n};\nvar masks = {\n  m: {\n    length: [1, 2],\n    regexp: new RegExp(\"^[1-9]$|^1[0-2]$\")\n  },\n  mm: {\n    length: [1, 2],\n    regexp: new RegExp(\"^[0-1]$|^0[1-9]$|^1[0-2]$\")\n  },\n  d: {\n    length: [1, 2],\n    regexp: new RegExp(\"^[1-9]$|^[1-2][0-9]$|^3[0-1]$\")\n  },\n  dd: {\n    length: [1, 2],\n    regexp: new RegExp(\"^[0-3]$|^0[1-9]$|^[1-2][0-9]$|^3[0-1]$\")\n  },\n  yy: {\n    length: [1, 2],\n    regexp: new RegExp(\"^[0-9]{1,2}$\")\n  },\n  yyyy: {\n    length: [1, 4],\n    regexp: new RegExp(\"^[0-9]{1,4}$\")\n  }\n};\nexport var schemaToMask = function schemaToMask(schema) {\n  if (!schema) return undefined;\n  return schema.map(function (part) {\n    var lower = part.toLowerCase();\n    var _char = lower[0];\n    if (_char === 'm' || _char === 'd' || _char === 'y') return _extends({\n      placeholder: part\n    }, masks[lower]);\n    return {\n      fixed: part\n    };\n  });\n}; // convert value into text representation using the schema\n\nexport var valueToText = function valueToText(value, schema) {\n  // when user initializes dates as empty array, we want to still\n  // show the placeholder text\n  if (!value || Array.isArray(value) && !value.length) return '';\n  var text = '';\n  var dates = (Array.isArray(value) ? value : [value]).map(function (v) {\n    return new Date(v);\n  });\n  var dateIndex = 0;\n  var parts = {};\n  schema.forEach(function (part) {\n    var _char2 = part[0].toLowerCase(); // advance dateIndex if we already have this part\n\n\n    while (dateIndex < dates.length && (Number.isNaN(dates[dateIndex].date) || (_char2 === 'm' || _char2 === 'd' || _char2 === 'y') && parts[part])) {\n      dateIndex += 1;\n      parts = {};\n    }\n\n    var date = dates[dateIndex];\n\n    if (date && part === 'm') {\n      text += date.getMonth() + 1;\n      parts[part] = true;\n    } else if (date && part === 'mm') {\n      text += (\"0\" + (date.getMonth() + 1)).slice(-2);\n      parts[part] = true;\n    } else if (date && part === 'd') {\n      text += date.getDate();\n      parts[part] = true;\n    } else if (date && part === 'dd') {\n      text += (\"0\" + date.getDate()).slice(-2);\n      parts[part] = true;\n    } else if (date && part === 'yy') {\n      text += date.getFullYear().toString().slice(-2);\n      parts[part] = true;\n    } else if (date && part === 'yyyy') {\n      text += date.getFullYear();\n      parts[part] = true;\n    } else text += part;\n  });\n  return text;\n};\nvar charCodeZero = '0'.charCodeAt(0);\nvar charCodeNine = '9'.charCodeAt(0);\n\nvar pullDigits = function pullDigits(text, index) {\n  var end = index;\n\n  while (text.charCodeAt(end) >= charCodeZero && text.charCodeAt(end) <= charCodeNine) {\n    end += 1;\n  }\n\n  return text.slice(index, end);\n};\n\nexport var textToValue = function textToValue(text, schema, valueProp) {\n  if (!text) return undefined;\n  var result;\n\n  var addDate = function addDate(parts) {\n    // do a little sanity checking on the values\n    if (!parts.m || !parts.d || !parts.y || parts.y.length < 4 || parts.m.length > 2 || parts.d.length > 2 || parts.m > 12 || parts.d > 31) return parts;\n    var date = new Date(parts.y, parts.m - 1, parts.d).toISOString(); // match time and timezone of any supplied valueProp\n\n    if (valueProp) {\n      var valueDate = new Date(valueProp).toISOString();\n      date = date.split('T')[0] + \"T\" + valueDate.split('T')[1];\n    } // single\n\n\n    if (!result) result = date; // second\n    else if (Array.isArray(result)) result.push(date); // third and beyond, unused?\n      else result = [result, date];\n    return {};\n  };\n\n  var parts = {};\n  var index = 0;\n  schema.forEach(function (part) {\n    if (index < text.length) {\n      var lower = part.toLowerCase();\n      var _char3 = lower[0];\n      if (parts[_char3] !== undefined) parts = addDate(parts);\n\n      if (_char3 === 'm') {\n        parts.m = pullDigits(text, index);\n        index += parts.m.length;\n      } else if (_char3 === 'd') {\n        parts.d = pullDigits(text, index);\n        index += parts.d.length;\n      } else if (_char3 === 'y') {\n        parts.y = pullDigits(text, index);\n        index += parts.y.length;\n\n        if (lower === 'yy' && parts.y.length === 2) {\n          // convert to full year, pivot at 69 based on POSIX strptime()\n          parts.y = \"\" + (parts.y < 69 ? 20 : 19) + parts.y;\n        }\n      } else if (text.slice(index, index + part.length) === part) {\n        index += part.length;\n      } else {\n        // syntax error\n        index = text.length;\n        result = undefined;\n      }\n    }\n  });\n  addDate(parts);\n  return result;\n};","map":{"version":3,"sources":["E:/react/my-app/node_modules/grommet/es6/components/DateInput/utils.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","formatToSchema","format","undefined","result","part","push","masks","m","regexp","RegExp","mm","d","dd","yy","yyyy","schemaToMask","schema","map","lower","toLowerCase","_char","placeholder","fixed","valueToText","value","Array","isArray","text","dates","v","Date","dateIndex","parts","forEach","_char2","Number","isNaN","date","getMonth","slice","getDate","getFullYear","toString","charCodeZero","charCodeAt","charCodeNine","pullDigits","index","end","textToValue","valueProp","addDate","y","toISOString","valueDate","split","_char3"],"mappings":"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","sourcesContent":["function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n// Converting between Date and String types is handled via a \"schema\".\n// The schema is an array of strings, split into strings with identical\n// characters. So, 'mm/dd/yyyy' will be ['mm', '/', 'dd', '/', 'yyyyy'].\nexport var formatToSchema = function formatToSchema(format) {\n  if (!format) return undefined;\n  var result = [];\n  var i = 0;\n  var part;\n\n  while (i < format.length) {\n    if (!part || part[0] !== format[i]) {\n      if (part) result.push(part);\n      part = format[i];\n    } else {\n      part += format[i];\n    }\n\n    i += 1;\n  }\n\n  if (part) result.push(part);\n  return result;\n};\nvar masks = {\n  m: {\n    length: [1, 2],\n    regexp: new RegExp(\"^[1-9]$|^1[0-2]$\")\n  },\n  mm: {\n    length: [1, 2],\n    regexp: new RegExp(\"^[0-1]$|^0[1-9]$|^1[0-2]$\")\n  },\n  d: {\n    length: [1, 2],\n    regexp: new RegExp(\"^[1-9]$|^[1-2][0-9]$|^3[0-1]$\")\n  },\n  dd: {\n    length: [1, 2],\n    regexp: new RegExp(\"^[0-3]$|^0[1-9]$|^[1-2][0-9]$|^3[0-1]$\")\n  },\n  yy: {\n    length: [1, 2],\n    regexp: new RegExp(\"^[0-9]{1,2}$\")\n  },\n  yyyy: {\n    length: [1, 4],\n    regexp: new RegExp(\"^[0-9]{1,4}$\")\n  }\n};\nexport var schemaToMask = function schemaToMask(schema) {\n  if (!schema) return undefined;\n  return schema.map(function (part) {\n    var lower = part.toLowerCase();\n    var _char = lower[0];\n    if (_char === 'm' || _char === 'd' || _char === 'y') return _extends({\n      placeholder: part\n    }, masks[lower]);\n    return {\n      fixed: part\n    };\n  });\n}; // convert value into text representation using the schema\n\nexport var valueToText = function valueToText(value, schema) {\n  // when user initializes dates as empty array, we want to still\n  // show the placeholder text\n  if (!value || Array.isArray(value) && !value.length) return '';\n  var text = '';\n  var dates = (Array.isArray(value) ? value : [value]).map(function (v) {\n    return new Date(v);\n  });\n  var dateIndex = 0;\n  var parts = {};\n  schema.forEach(function (part) {\n    var _char2 = part[0].toLowerCase(); // advance dateIndex if we already have this part\n\n\n    while (dateIndex < dates.length && (Number.isNaN(dates[dateIndex].date) || (_char2 === 'm' || _char2 === 'd' || _char2 === 'y') && parts[part])) {\n      dateIndex += 1;\n      parts = {};\n    }\n\n    var date = dates[dateIndex];\n\n    if (date && part === 'm') {\n      text += date.getMonth() + 1;\n      parts[part] = true;\n    } else if (date && part === 'mm') {\n      text += (\"0\" + (date.getMonth() + 1)).slice(-2);\n      parts[part] = true;\n    } else if (date && part === 'd') {\n      text += date.getDate();\n      parts[part] = true;\n    } else if (date && part === 'dd') {\n      text += (\"0\" + date.getDate()).slice(-2);\n      parts[part] = true;\n    } else if (date && part === 'yy') {\n      text += date.getFullYear().toString().slice(-2);\n      parts[part] = true;\n    } else if (date && part === 'yyyy') {\n      text += date.getFullYear();\n      parts[part] = true;\n    } else text += part;\n  });\n  return text;\n};\nvar charCodeZero = '0'.charCodeAt(0);\nvar charCodeNine = '9'.charCodeAt(0);\n\nvar pullDigits = function pullDigits(text, index) {\n  var end = index;\n\n  while (text.charCodeAt(end) >= charCodeZero && text.charCodeAt(end) <= charCodeNine) {\n    end += 1;\n  }\n\n  return text.slice(index, end);\n};\n\nexport var textToValue = function textToValue(text, schema, valueProp) {\n  if (!text) return undefined;\n  var result;\n\n  var addDate = function addDate(parts) {\n    // do a little sanity checking on the values\n    if (!parts.m || !parts.d || !parts.y || parts.y.length < 4 || parts.m.length > 2 || parts.d.length > 2 || parts.m > 12 || parts.d > 31) return parts;\n    var date = new Date(parts.y, parts.m - 1, parts.d).toISOString(); // match time and timezone of any supplied valueProp\n\n    if (valueProp) {\n      var valueDate = new Date(valueProp).toISOString();\n      date = date.split('T')[0] + \"T\" + valueDate.split('T')[1];\n    } // single\n\n\n    if (!result) result = date; // second\n    else if (Array.isArray(result)) result.push(date); // third and beyond, unused?\n      else result = [result, date];\n    return {};\n  };\n\n  var parts = {};\n  var index = 0;\n  schema.forEach(function (part) {\n    if (index < text.length) {\n      var lower = part.toLowerCase();\n      var _char3 = lower[0];\n      if (parts[_char3] !== undefined) parts = addDate(parts);\n\n      if (_char3 === 'm') {\n        parts.m = pullDigits(text, index);\n        index += parts.m.length;\n      } else if (_char3 === 'd') {\n        parts.d = pullDigits(text, index);\n        index += parts.d.length;\n      } else if (_char3 === 'y') {\n        parts.y = pullDigits(text, index);\n        index += parts.y.length;\n\n        if (lower === 'yy' && parts.y.length === 2) {\n          // convert to full year, pivot at 69 based on POSIX strptime()\n          parts.y = \"\" + (parts.y < 69 ? 20 : 19) + parts.y;\n        }\n      } else if (text.slice(index, index + part.length) === part) {\n        index += part.length;\n      } else {\n        // syntax error\n        index = text.length;\n        result = undefined;\n      }\n    }\n  });\n  addDate(parts);\n  return result;\n};"]},"metadata":{},"sourceType":"module"}